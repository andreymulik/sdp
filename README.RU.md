# Simple Data Processing

Это библиотека для простой обработки данных. SDP вдохновлена array, vector,
bytestring, отчасти containers и repa.

SDP ориентирована на эффективность и открытость, поэтому в ней есть небезопасные
функции.

## tl;dr

SDP объединяет лучшие возможности основных библиотек структур Haskell Platform.

sdp - функциональный аналог array, но структуры имеют более эффективное
представление. То, чего в sdp нет, реализовано в расширениях sdp-ioarrays и
sdp-ctypes.

sdp почти взаимозаменяема с vector и containers. В некоторых случаях sdp может
заменить bytestring (Bytes и ByteList - аналоги строгой и ленивой bytestring).

## Мотивация

Назначение SDP - предоставлять наиболее комфортный интерфейс для работы с
различными структурами данных в одном пространстве имён без квалифицированных
импортов, сохраняя при этом достаточно высокое качество кода и скорость работы,
чтобы её можно было использовать на практике, а перевод программ со старых и
более узконаправленных библиотек не вызвал бы серьёзных проблем.

## Функционал

SDP предоставляет большой набор функций для конвертации, мощную абстракцию
данных для написания обобщённых алгоритмов и наиболее востребованные операции,
включая (но не ограничиваясь) выборку, разбиение и сортировку.

С SDP списочные функции не перекрывают свои аналоги для структур.

В SDP есть 12 структур различной степени полезности:
- массивы: Array и Bytes
- развёрнутые списки: Unlist, Ublist, Unrolled и ByteList
- изменяемые массивы: STArray и STBytes
- изменяемые развёрнутые списки: STUnrolled, STUnlist, STByteList и STUblist

Также в SDP есть псевдо-примитивные типы (SArray#, SBytes#, STArray# и STBytes#),
которые упрощают реализацию более высокоуровневых структур. Они защищены от
прямого воздействия и дают некоторые важные гарантии, которые не могут дать
настоящие примитивы вроде Array# и ByteArray#.

SDP предоставляет следующие классы:

- Bordered, Linear and Indexed - основные операции.
- BorderedM, LinearM and IndexedM - базовые монадические операции.
- IFold and IFoldM - свёртки с индексами. Для некоторых структур могут заменять
Foldable.
- Sort and SortM - классы сортируемых структур.
- Set and Map - классы операций над множествами и словарями.
- Index, Unboxed, Estimate, Zip and Scan - сервисные классы.

## Версии

SDP соответствует [Haskell Package Versioning Policy](https://pvp.haskell.org).
Для упрощения поиска производных компонентов, я предлагают такие правила:
* МАЖОРНАЯ версия должна соответствовать наименьшей МАЖОРНОЙ версии SDP, с
которой она совместима.
* МИНОРНАЯ версия оставляется на усмотрение разработчика.
* Расширения SDP должны называться по правилу sdp-%имярасширения%.
* Обёртки SDP должны называться sdp2%имябиблиотеки% (для библиотек, уже имеющих
большую часть функционала обёртки и нуждающихся только в небольшом обобщении).
Либо sdp4%имябиблиотеки% - для бедных библиотек, которые не только обобщаются,
но и расширяются обёрткой.

## Отличия от других похожих проектов

* Внутренняя непротиворечивость. Я был бы искренне счастлив, если бы все
библиотеки были последовательными и непротиворечивыми. Хотя бы в Haskell
Platform.
* Максимальная функциональность при минимальном числе зависимостей и размере.
SDP требует лишь самые необходимые и общеупотребительные пакеты. Это одна из
причин, по которым я отказался от использования некоторых библиотек как
зависимостей (например, containers, в которой много повторяющегося кода и array,
которая полагается на откровенно слабый класс Ix).
* Хорошая расширяемость. SDP основана на классах типов, а не на структурах. Она
предоставляет простейшие интерфейсы для работы с различными представлениями
данных и реализациями, уменьшает дублирование кода. SDP не потребует от вас
квалифицированного импорта для работы с разными типами в одном пространстве имён
или переписывания половины кода для интеграции.
* Ориентация на другие библиотеки. SDP взаимозаменяема с array и vector, а в
некоторых случаях - с containers и bytestring. Но это не её основное назначение.
SDP должна помогать другим библиотека взаимодействовать друг с другом.

## Использование категории SDP

Категория SDP должна использоваться для:
* классов типов SDP и расширений
* для типов, имена которых уже заняты в категории Data (например, Array не может
быть помещён в Data.Array из-за конфликта с модулем из пакета array)
* типов, аналогичных тем, которые уже есть в категории SDP (например, Bytes
аналогичен Array и помещать его в Data.Bytes было бы контринтуитивно)
* для типов, основанных на псевдо-примитивах SDP (STUnlist, STUblist, а также
основанные на них Unrolled и ByteList)
* модулей-обёрток, чтобы не нагромождать 3-5-уровневые иерархии (например,
обёртка для Data.ByteString - SDP.ByteString, а не Data.ByteString.SDP и обёртка
для Data.ByteString.Lazy - SDP.ByteString.Lazy, а не Data.ByteString.Lazy.SDP
или Data.ByteString.SDP.Lazy)

Категория SDP не должна использоваться для:
* типов из Foreign и других важных категорий (например, instance'ы для типов из
Foreign.C должны быть в Foreign.C.SDP, а не в SDP.C или SDP.Foreign.C)
* типов исключений (по аналогии с Control.Exception.SDP)
* небиблиотечных модулей (должны быть в SDP.Internal)

Test.SDP должен использоваться только для тестирования классов.

## Содействие

Информация о процессе подачи запросов (pull request) находится в
[CONTRIBUTING.md](https://github.com/andreymulik/sdp/blob/master/CONTRIBUTING.md).

## Лицензия

SDP - свободное ПО, вы можете распространять её и/или улучшать по условиям BSD3.
SDP распространяется в надежде на практическую полезность, но без гарантий
товарной пригодности или пригодности для конкретных целей. Подробнее см. BSD3 в
файле LICENSE (прилагается).



