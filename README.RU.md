# SDP

Это библиотека для простой обработки данных.

## Мотивация

Назначение SDP - предоставлять наиболее комфортный интерфейс для работы с
различными структурами данных в одном пространстве имён, сохраняя при этом
достаточно высокое качество кода и скорость работы, чтобы её можно было
использовать на практике, а перевод программ со старых и более узконаправленных
библиотек не вызвал серьёзных проблем.

Классы SDP не стремятся охватить все возможные структуры данных - только
простейшие из них. Впрочем, именно такие структуры и требуются в 80-95% случаев.

## Функционал

SDP предоставляет широкий выбор средств преобразования данных между различными
структурами данных, мощную абстракцию данных для написания обобщённых алгоритмов
и множество наиболее востребованных операций, включая (но не ограничиваясь)
выборку, разбиение и сортировку.

На данный момент в SDP есть лишь 6 структур данных для использования в не
слишком требовательных к скорости и эффективности программах:

- стадартные списки ([])
- бинарные деревья  (BinTree)

- "ленивые" массивы (Array, STArray)
- "строгие" массивы (Bytes, STBytes)

- "ленивые" развёрнутые списки (Unrolled, STUnrolled)
- "строгие" развёрнутые списки (ByteList, STByteList)

И две сервисные структуры (могут быть потенциально бесконечными):

- "ленивые" развёрнутые списки (Unlist, STUnlist)
- "строгие" развёрнутые списки (Ublist, STUblist)

Но скоро будут добавлены матрицы, битовые массивы, последовательности, словари и
префиксные деревья.

SDP предоставляет следующие классы:

- Bordered/BorderedM - для получения границ, списков индексов и ассоциаций
(индекс, элемент).
- Linear - для отделения элементов, создания структур из списков и Foldable,
левых и правых сечений. Также содержит обобщённые списочные функции (concat,
intersperse, filter, partition, reverse и nubBy), поддерживает 3 view pattern'а.
- Indexed/IndexedM - для создания структур из списка ассоциаций или других
Indexed/IndexedM, для их перезаписи и обновления, для чтения и записи (4 и 2
функции/процедуры соответственно) и для поиска индексов по условию.
- IFold - для свёрток с индексом.
- Sort/SortM - для сортировки структур. Также SDP содержит реализацию алгоритма
timSort для всех IndexedM.
- Set - для стандартных операций над множествами.

- Zip and Scan - для перегруженных zip'ов и scan'ов (только для структур,
перегруженных по типу элементов).

- Estimate - для ленивого сравнения по длине.
- Unboxed - перегруженный по типу элемента интерфейс для создания, заполнения,
записи и чтения ByteArray.
- Index - для типов индексов.
- IndexEQ - для простых, но нудных instance'ов (лучше потерять немного в
производительности, чем искать ошибки в сотне строк однообразного кода).

## Версии

SDP и основанные на ней расширения/обёртки должны следовать принципам
версионирования, установленными сообществом разработчиков Haskell, со следующими
ограничениями:

SDP and SDP-derived libraries must follow of the Haskell community versioning
principles and this restrictions:

Для версии a.b.c.d:
* d - номер патча: только для исправлений и небольших улучшений в коде. Также
можут использоваться для правки допустимых версий зависимостей.
* c - номер для внутренних целей библиотеки, успользуется чтобы отметить
изменения в API (только небольшие расширения - старый код должен компилироваться
в любом случае) и улучшения кода.
* b - номер стабильной версии SDP. Устаревшее (deprecations) не может быть
удалено до выхода новой стабильной версии. Номер стабильной версии
расширения/обёртки должен соответствовать НАИМЕНЬШЕЙ совместимой стабильной
версии SDP.
* a - зарезервировано (всегда 0) - нужно на случай выхода новой редакции SDP.

## Отличия от других похожих проектов

* Внутренняя непротиворечивость. Я был бы искренне счастлив, если бы все
библиотеки были последовательными и непротиворечивыми. Хотя бы в Haskell
Platform (впрочем, не буду показывать пальцем).
* Максимальная функциональность при минимальном числе зависимостей. SDP требует
лишь самые необходимые и общеупотребительные пакеты. Это одна из причин, по
которым я отказался от использования некоторых библиотек как зависимостей
(например, containers, в которой много повторяющегося кода и array, которая
полагается на откровенно слабый класс Ix).
* Ориентация на другие библиотеки. SDP вряд ли будет использоваться сама по
себе, зато она может стать мостом между другими библиотеками и структурами.
Исходя из этого предположения, SDP не даёт собственным реализациям структур
преимущества перед сторонними (кроме, разве что, добровольно-принудительного
использования своей реализации индексов). Вы можете добавить реализации ключевых
классов для любых структур и они будут прекрасно взаимодействовать как с
"родными", так и между собой. Если то же самое сделают и другие разработчики, то
писать код станет ещё чуточку проще.
* Хорошая расширяемость. Основу SDP составляют классы типов, а не структуры.
Она предоставляет простейшие интерфейсы для работы с различными представлениями
данных и реализациями, уменьшает дублирование кода (как в рамках самой
библиотеки, так и в её применениях). SDP не потребует от вас квалифицированного
импорта для работы с разными типами в одном пространстве имён или переписывания
половины кода для интеграции.

## Производные библиотеки

Лицензия SDP разрешает любые производные компоненты (библиотеки или приложения).
Если Вы хотите создать некоторый инструмент на основе SDP, вот список простых
правил, которые помогут другим быстро найти его, понять что он делает и с какими
версиями SDP совместим:

### Расширения

Расширения SDP (библиотеки, добавляющие новый функционал в SDP) должны следовать
следующему правилу именования: sdp-%имярасширения% (например, sdp-io или
sdp-binary) и вышеупомянутым правилам версионирования.

### Обёртки

Обёртки SDP (библиотеки, предоставляющие функционал SDP для существующих
библиотек должны следовать следующему правилу именования
* sdp4%имябиблиотеки% - для библиотек, которые хороши сами по себе, в обёртка
нужна только для удобства.
* sdp2%имябиблиотеки% - для библиотек с ограниченным функционалом и/или плохим
API (компромисс между Последними Китайскими Предупреждениями и форком).

## Содействие

Информация о процессе подачи запросов (pull request) находится в
[CONTRIBUTING.md](https://github.com/andreymulik/sdp/blob/master/CONTRIBUTING.md).

## Лицензия

SDP - свободное ПО, вы можете распространять её и/или улучшать по условиям BSD3.
SDP распространяется в надежде на практическую полезность, но без гарантий
товарной пригодности или пригодности для конкретных целей. Подробнее см. BSD3 в
файле LICENSE (прилагается).
