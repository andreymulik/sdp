# SDP

Это библиотека для простой обработки данных. SDP вдохновлена array, vector,
bytestring, отчасти containers и repa.

SDP ориентирована на эффективность и открытость, поэтому в ней есть небезопасные
функции.

## tl;dr

SDP объединяет лучшие (по моему скромному мнению) возможности array, vector,
containers и bytestring. Она полностью взаимозаменяема с первыми двумя,
почти - с третьей и частично с четвёртой.

## Мотивация

Назначение SDP - предоставлять наиболее комфортный интерфейс для работы с
различными структурами данных в одном пространстве имён без квалифицированных
импортов, сохраняя при этом достаточно высокое качество кода и скорость работы,
чтобы её можно было использовать на практике, а перевод программ со старых и
более узконаправленных библиотек не вызвал бы серьёзных проблем.

## Функционал

SDP предоставляет большой набор функций для конвертации, мощную абстракцию
данных для написания обобщённых алгоритмов и наиболее востребованные операции,
включая (но не ограничиваясь) выборку, разбиение и сортировку.

В SDP есть 12 структур различной степени полезности.

- стандартные списки []. С SDP списочные функции не перекрывают свои аналоги
для структур.
- неизменяемые массивы (ленивый Array и строгий Bytes). Аналогичны массивам из
пакета array, но имеют более богатый функционал. SDP использует наработки vector
и containers чтобы сделать некоторые операции быстрее (O(1) вместо O(n)).
- неизменяемые развёрнутые списки (ленивые Unlist и Unrolled, строгие Ublist и
ByteList). Ublist - параметризованная версия lazy ByteString (может содержать
элементы любого Unboxed типа, а не только Word8 или Char). Unlist - boxed версия
Ublist. Unrolled и ByteList - версии Unlist и Ublist с явно заданными границами
типа Index.
- изменяемые массивы и развёрнутые списки (STArray, STBytes, STUnrolled,
STUnlist, STByteList, STUblist).

Также в SDP есть псевдо-примитивные типы (SArray#, SBytes#, STArray# и STBytes#),
которые упрощают реализацию более высокоуровневых структур. Они защищены от
прямого воздействия и дают некоторые важные гарантии, которые не могут дать
настоящие примитивы вроде Array# и ByteArray#.

SDP предоставляет следующие классы:

- Bordered/BorderedM - для получения операций границами
- Linear, LinearM - для создания и деконструкции структур с помощью стандартных
списков или их Foldable аналогов. Linear также предоставляет универсальные
паттерны и аналоги простых списочных операций (filter, concat, reverse, nub и
т.п.).
- Indexed, IndexedM - для создания структур из списка ассоциаций или других
Indexed/IndexedM, для их перезаписи и обновления, для чтения и записи.
- IFold, IFoldM - для свёрток с индексом, также расширяет Foldable на Indexed-
типы (например, Bytes и ByteList не могут быть Foldable, но могут быть IFold).
- Sort, SortM - для сортировки структур. Также SDP содержит реализацию алгоритма
timSort для всех IndexedM.
- Set, Map - для стандартных операций над множествами и словарями.
- Zip, Scan - для перегруженных zip'ов и scan'ов (только для структур,
перегруженных произвольному по типу элементов).
- Estimate - для ленивого сравнения по длине.
- Unboxed - перегруженный по типу элемента интерфейс для создания, заполнения,
записи и чтения ByteArray.
- Index - для типов индексов.

## Версии

SDP соответствует [https://pvp.haskell.org](Haskell Package Versioning Policy).
Для упрощения поиска производных компонентов, я предлагают такие правила:
* МАЖОРНАЯ версия должна соответствовать наименьшей МАЖОРНОЙ версии SDP, с
которой она совместима.
* МИНОРНАЯ версия оставляется на усмотрение разработчика.
* Расширения SDP должны называться по правилу sdp-%имярасширения%.
* Обёртки SDP должны называться sdp2%имябиблиотеки% (для библиотек, уже имеющих
большую часть функционала обёртки и нуждающихся только в небольшом обобщении).
Либо sdp4%имябиблиотеки% - для бедных библиотек, которые не только обобщаются,
но и расширяются обёрткой.

## Отличия от других похожих проектов

* Внутренняя непротиворечивость. Я был бы искренне счастлив, если бы все
библиотеки были последовательными и непротиворечивыми. Хотя бы в Haskell
Platform.
* Максимальная функциональность при минимальном числе зависимостей и размере.
SDP требует лишь самые необходимые и общеупотребительные пакеты. Это одна из
причин, по которым я отказался от использования некоторых библиотек как
зависимостей (например, containers, в которой много повторяющегося кода и array,
которая полагается на откровенно слабый класс Ix).
* Хорошая расширяемость. SDP основана на классах типов, а не на структурах. Она
предоставляет простейшие интерфейсы для работы с различными представлениями
данных и реализациями, уменьшает дублирование кода. SDP не потребует от вас
квалифицированного импорта для работы с разными типами в одном пространстве имён
или переписывания половины кода для интеграции.
* Ориентация на другие библиотеки. SDP взаимозаменяема с array и vector, а в
некоторых случаях - с containers и bytestring. Но это не её основное назначение.
SDP должна помогать другим библиотека взаимодействовать друг с другом.

## Содействие

Информация о процессе подачи запросов (pull request) находится в
[CONTRIBUTING.md](https://github.com/andreymulik/sdp/blob/master/CONTRIBUTING.md).

## Лицензия

SDP - свободное ПО, вы можете распространять её и/или улучшать по условиям BSD3.
SDP распространяется в надежде на практическую полезность, но без гарантий
товарной пригодности или пригодности для конкретных целей. Подробнее см. BSD3 в
файле LICENSE (прилагается).

